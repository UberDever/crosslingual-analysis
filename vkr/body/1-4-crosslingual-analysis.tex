\section{Анализ существующих подходов к статическому анализу, проектирование архитектуры и
исследование средств реализации}

\subsubsection{Виды структур представления информации в статическом анализе}

Из подраздела \ref{ssec:2:results} становится ясно, что в отношении мультиязыкового анализа
основополагающим механизмом является наличие общей структуры представления информации, позволяющей отражать различные
сущности различных языков в единой форме. Выбор такой структуры может влиять на следующие
характеристики метода анализа:
\begin{itemize}
    \item разнообразие поддерживаемых языков,
    \item сложность разработки и поддержки анализаторов,
    \item корректность и полнота анализа,
    \item возможные сценарии использования.
\end{itemize}
В целом, выбор структуры влияет практически на все характеристики метода, поэтому стоит
исследовать существующие структуры представления информации о программном коде.

\hyperlink{AST}{AST} представляет собой репрезентацию программного кода в древовидном формате. В качестве узлов дерева выступают различные синтаксические конструкции, а в качестве ребер связи между ними. AST является
простой и универсальной структурой данных, позволяющей реализовывать множество анализов. Также,
носителем AST может быть любой структурный формат (например S-выражения), что упрощает его
построение, сериализацию и анализ. Однако, в контексте мультиязыкового анализа AST является
неудобным решением, в первую очередь потому что оно часто вовлекает языкоспецифичные конструкции.
К примеру, в некоторых языках отсутствует понятие <<оператор>> (англ statement), что различает
AST таких языков от императивных языков на фундаментальном уровне.

eCST \cite{eCST} является попыткой расширения концепции AST (а точнее \hyperlink{CST}{CST}) на большее
количество языков. Авторы достигают этого путем введения универсальных узлов, позволяющих
отражать общие семантические концепции (итерацию, выбор или переход). К сожалению, такой формат
представления информации всё еще неудобен так как языкоспецифичные узлы не могут быть конвертированы
в такие универсальные узлы и остаются в дереве в первозданном виде.

\hyperlink{CFG}{CFG} это граф, узлы которого представляют собой в общем случае операторы, а ребра
поток управления. Такой граф полезен в первую очередь для компиляторных трансформаций и оптимизаций,
так как позволяет моделировать исполнение программы и выстраивать на основе этого определенные инварианты.
Граф является основой для фреймворков монотонного анализа \cite{static-program-analysis} и активно
используется в различных инструментах. Несмотря на достоинства, как и в случае с AST такой граф
имеет зависимость от представляемого языка. Также, анализ потока управления сложен в контексте
мультиязыкового статического анализа и проще осуществим в рамках динамического анализа.

\hyperlink{CDG}{CDG} является формой представления информации о вызовах процедур друг другом в контексте
определенного фрагмента кода. Соотвественно, узлы такого графа обычно составляют идентификаторы
процедур, а ребра зависимость <<вызывает>>. Стоит сказать, что зависимость <<вызывает>> обычно является
направленной, поэтому граф имеет направление ребер. Такой граф является хорошим кандидатом на универсальное
представление в рамках мультиязыкового анализа, что уже было исследовано в \cite{MLSA}. Как было
сказано в подразделе \ref{ssec:mlsa}, основным недостатком графа зависимостей вызовов является
его ориентированность на процедуры -- исполняемые фрагменты кода. Это делает невозможным его применение
в рамках других языков, в первую очередь форматов данных. Действительно, в современных приложениях
семантически важная информация часто содержится в различных конфигурационных файлах, например XML или
INI.

Система типов обычно не является ни структурой данных ни моделью представления семантической информации.
Её основное назначение заключается именно в проверке программ на определенные классы ошибок,
что достигается путем задания определенного набора суждений о сущностях в программе с
их дальнейшей автоматической проверкой.
Однако, современные исследования в области системы типов показывают, что
есть возможность кодирования и эффективной проверки ряда свойств программного кода, часть
которых раньше могла быть проверена только интенсивным статическим анализом. Примером является
механизм borrow-checking в языке Rust \cite{rust}, который базируется на системе типов известной
как система \textit{владения}. Такой механизм позволяет проверять и устранять класс ошибок связанных
с системными ресурсами: использование после освобождения, предотвращенние гонок данных и другие.
В контексте мультиязыкового анализа система типов точно имеет первостепенное значение, так
как создание корректных анализаторов возможно в том числе за счет использования корректной
системы типов. Однако, одной системы типов для совершения анализа недостаточно, так как
обычно ограничения на типы сущностей не берут в расчет механизмы областей видимости языков
и семантику зависимостей сущностей между собой.

Таблица символов является повсеместной структурой данных (особенно в императивных языках) и
используется в первую очередь для представления различной информации об идентификаторах. Так,
таблица символов обычно содержит данные о местонахождении определения (или объявления) сущности,
её тип, контекст в котором она определена и множество других атрибутов, специфичных для конкретного
языка. Структурно таблица символов представляет собой набор пар (идентификатор, атрибуты).
Первым и значимым расширением концепции таблицы символов является введение понятия \textit{области видимости}.
В языках с лексической областью видимости таблица символов является не таблицей, а стеком таблиц --
это необходимо для отражения отношения вложенности между областями видимости. Таблица символов
является очень хорошим решением в контексте мультиязыкового анализа, но имеет один серьезный недостаток.
Он заключается в отсутствии возможности однозначного кодирования нелексических
областей видимости, например в случае присутствия в языке механизма классов или модулей.

Граф свойств может быть определен в терминах теории графов как направленный 
мультиграф с метками вершин и ребер с собственными ребрами, 
где ребра имеют собственную идентичность \cite{property-graph}.
Такие графы активно используются в графовых базах данных и хорошо подходят для отражения
разноструктурированной онтологической информации о сущностях в области знаний.
Например, формат RDF \cite{RDF} является основным способом представления информации
в семантических сетях Интернета. Основанные на нем языки отражения онтологических
понятий позволяют создавать машинно-читаемые семантические структуры.
Основным недостатком графов свойств в контексте мультиязыкового анализа ПО является отсутствие
сколько нибудь универсальной единой онтологической модели. Соотвественно, существующие
модели (что рассмотрены в подразделе \ref{ssec:pangea}) являются специфичными решениями.
Также, создание и поддержка таких моделей является довольно трудоемким процессом, так как требует
достаточной компетенции специалиста.

Таким образом, на данный момент не существует идеальной структуры представления информации
для осуществлений мультиязыкового анализа. Однако, существующие структуры и модели дают
представление о том, какой она могла бы быть -- идеальная модель являлась бы совмещением
концепций системы типов и таблицы символов, с дополнительной возможностью связывания
понятий по онтологическим признакам в определенные графы свойств. Таким образом, так или иначе
такая модель должна реализовывать формат семантической сети в общем случае.

% eCST: https://arxiv.org/pdf/1310.0802.pdf

% SPA 

% file:///home/uber/dev/mag/crosslingual-analysis/reports/sem2/%D0%9E%D1%80%D0%BB%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9%D0%9C%D0%AE_%D0%9E%D1%82%D1%87%D0%B5%D1%82_%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0.pdf
% Различные подходы к семантической инфе 1.3 + проблема модулей
% file:///home/uber/dev/mag/crosslingual-analysis/reports/sem3/%D0%9E%D1%80%D0%BB%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9%20%D0%9C.%D0%AE.%20%D0%9E%D1%82%D1%87%D0%B5%D1%82%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0.pdf

\subsubsection{Парсинг мультиязыковых фрагментов кода}

Как было сказано в подразделе \ref{ssec:parsing-problem}, парсинг текста является одной из первых
задач, которые необходимо решить при мультязыковом анализе. При наличии единой модели представления информации,
однако, такая задача существенно упрощается.

Дело в том, что используя единую модель состоящую из графа можно достичь разделения этапов
извлечения информации о графе и анализа самого графа. Похожий подход используется, например, при
реализации проверки типов методом Хиндли-Милнера \cite{algorithm-W}. Суть алгоритма заключается
в использовании т.н. \textit{ограничений} которые извлекаются из кода. Такие ограничения являются
утверждениями о сущностях и в дальнейшем решаются вместе для создания специальной подстановки, которая
позволит удовлетворить все ограничения. Такой процесс решения называется \textit{унификацией}.

По тому же принципу можно построить модель для мультиязыкового анализа, если в качестве ограничений
воспринимать отношения узлов в графе, а в качесте процесса унификации процесс построения самого графа. Такой
механизм распределенного анализа позволяет достичь трех целей:
\begin{itemize}
    \item разделение метода на два этапа (генерация ограничений и их разрешение), что повышает
    модульность анализатора, его универсальность и открывает возможности для параллелизации,
    \item объединение анализаторов таким представлением как ограничения позволяет решить проблему
    парсинга мультиязыковых фрагментов путем реализации специализированных (заточенных под конкретный
    язык) анализаторов,
    \item открываются возможности для реализации инкрементального анализа и анализа неполного графа, что
    критично для таких средств как IDE и линтеры.
\end{itemize}

Таким образом, такие анализаторы являются \textit{трансляторами} из избранного языка в унифицированное представление,
заданное в виде ограничений.

Стоит заметить, что создание раздельных трансляторов под конкретный язык всё еще не решает проблему
взаимодействия языков в общем случае, так как часто в коде на избранном языке встречаются фрагменты
кода, реализованные на других языках. Обычно, такой код представляется строковым литералом. К примеру,
фрагменты такого <<встроенного>> кода могут включать:
\begin{itemize}
    \item путь к файлу или ресурсу (в формате URI),
    \item данные в определенном формате (например XML, JSON...),
    \item строка запроса к БД (например SQL),
    \item шаблон документа или веб страницы (в формате HTML),
\end{itemize}

Такие фрагменты в общем случае сложно обнаружить в исходном коде так как строковые литералы
могут быть представлены в любом выражении. Решением данной проблемы может служить инструмент
распознавания определенного языка программирования по входной строке. Таким образом,
трансляция определенного языка будет вовлекать распознавание фрагментов языков, описанных через строковые литералы.
После распознавания такие фрагменты будут направлены соответствующим трансляторам.

Таким образом, общий алгоритм трансляции выглядит следующим образом:
\begin{enumerate}[label=\arabic*.]
    \item на вход транслятору поступает фрагмент кода на определенном языке,
    \item транслятор использует любые подходящие средства для анализа и трансляции данного кода
    (AST, CFG, абстрактная интерпретация и т.д.),
    \item если транслятор обнаруживает строковый литерал он может отправить его на распознавание, которое
    позволит определить язык избранного фрагмента и в дальнейшем направить этот фрагмент другому транслятору,
    \item все трансляторы всех языков выводят ограничения в общий буфер, для последующего разрешения.
\end{enumerate}

Как видно из алгоритма, универсальное представление позволяет реализовывать гибкий анализ кода --
сам процесс анализа зависит от конкретного транслятора и может вовлекать любые методы, вплоть до интерпретации
или компиляции. Также такая трансляция происходит независимо от остальных трансляторов, что
позволяет проводить анализ проектов инкрементально и по требованию.

\subsubsection{Унифицированное представление через ограничения}

В ходе работы над проектом были реализованы несколько представлений, способных быть достаточно универсальными
и при этом распределенными. Были рассмотрены такие структуры как семантическая сеть и дерево модулей, однако
такие представления ориентированы на другие сценарии использования, поэтому их корректная
адаптация под статический анализ затруднительна. Однако, общей идеей в обоих структурах было 
создание графа \textit{идентификаторов}, каждый из которых обладал бы одной из двух
семантик: либо \textit{объявление}, либо \textit{ссылка}.

Объявлением называется семантика создания имени ресурса. Если при этом ресурс привязывается к такому имени, то
такое действие называется определением. Ссылкой же называется дальнейшее упоминание такого имени в тексте
программы. В контексте мультиязыкового статического анализа данную семантику можно понимать следующим образом.

Объявлением является идентификатор, находящийся в определенном фрагменте кода определенного языка и факт того, является
ли идентификатор объявлением определяется транслятором этого языка. Ссылкой является идентификатор находящийся \textit{в
другом фрагменте кода, реализованным на другом языке}. Факт того, что идентификатор является ссылкой тоже определяется
транслятором избранного языка. Таким образом создается набор идентификаторов, определенные из которых можно сопоставить друг
с другом, получив таким образом пары (объявление, ссылка).
Эта базовая идея позволяет обнаруживать различные межъязыковые связи различной природы, так как на вид самого идентификатора
не налагается никаких ограничений -- это может быть URI файла, имя функции, имя модуля или ключ в БД.

Однако, современные проекты в подавляющем большинстве случаев структурированы с учетом изоляции имен. Такой механизм
обычно называется механизмом \textit{областей видимости}. Описанная выше схема пренебрегает таким механизмом, что
ведет в сущности к лексическому сопоставлению идентификаторов, который не обладает ни должной корректностью, ни полнотой.

Учитывая, что понятие области видимости тесно связано с понятием <<модуль>> (так как последний часто определяется
как именованная область видимости с возможностью импорта),
логичным решением является использование универсальной системы модулей для организации идентификаторов в области
видимости. Одной из таких систем может являться механизм \textit{графов областей видимости} \cite{scope-graphs}.
Графы областей видимости (далее просто графы областей) являются языконезависимой теорией описания таких
механизмов как привязка имен и их разрешение. В оригинальной статье авторами создается соответствующий граф,
узлами которого могут выступать идентификаторы и области видимости, а ребрами -- различные отношения между ними. В граф входят
такие бинарные отношения как:
\begin{itemize}
    \item объявлен в,
    \item имеет ссылку в,
    \item должен быть разрешен в,
    \item родительская область видимости,
    \item достижим,
    \item видим,
\end{itemize}

Как видно из списка, данные отношения позволяют задавать богатую семантику разрешения имен, при этом
не используя понятия определенного языка программирования. Авторам удается реализовать семантику
импорта и включения модулей, а также структуру лексических областей видимости.

Данный фреймворк хорошо подходит для данной задачи, однако в дальнейшем авторами оригинальной статьи
был создан другой, более подходящий для статического анализа фреймворк. В статье \cite{scope-graphs-static-analysis}
описывается метод генерации графа областей через использование ограничений, ориентированный на реализацию
статических анализаторов. Интерес в первую очередь представляют результаты работы авторов -- им удалось
существенно упростить фреймворк и включить более универсальные отношения в граф, за счет чего им удается увеличить
количество информации, которую можно представить таким графом. 

Основным изменением по сравнению с оригинальной работой 2015 года, однако стало введение типов. В смежной работе
\cite{scope-graphs-typed} авторами рассмотрен механизм графов областей в сочетании с которым вводится еще один тип
ограничений -- ограничения на типы идентификаторов. Такой подход позволяет реализовать \textit{смешанное} разрешение
имени, когда процесс разрешения вовлекает как поиск идентификатора в графе, так и вывод типа. Основной причиной
введения такого механизма стало использование таких языковых конструкций как записи. В отличие от модулей, записи
могут иметь экземпляры, то есть в процесс разрешения поля записи вовлекается процесс разрешения типа экземпляра переменной.

Стоит заметить очень важную особенность фреймворка -- авторами тщательно доказываются все заявленные свойства
через задание формальной семантики. Таким образом обеспечивается корректность алгоритма разрешения имен с учетом
изложенного исчисления.

В качестве базы модели разрабатываемого метода анализа используется граф областей видимости в редакции статьи \cite{scope-graphs-static-analysis}
, то есть задаваемый через ограничения. В отличие от графа описанного в \cite{scope-graphs-typed},
данный граф имеет более простую организацию и не вовлекает отношение подтипирования. Помимо тех ограничений, собираемых
в ходе построения графа областей и анализа типов идентификаторов решено было ввести дополнительные виды ограничений,
позволяющих обеспечивать проверку дальнейшую корректности связей в проекте. Таким образом, все задействованные
в методе анализа виды ограничений отражены в таблице \ref{all-constraints}.
% \resizebox{1 \textwidth}{!}{\begin{tabular}{|p{3cm}|p{3cm}|p{8cm}|p{5cm}|}
\begin{longtable}{| p{.20\textwidth} | p{.80\textwidth} |}
    \hline Ограничение & Вид ограничения & Вовлекаемые узлы & Назначение  \\
    \hline Объявление\slash Ссылка & Ограничение графа областей &  Область видимости в которой упомянут идентификатор,
    Идентификатор; & Связывание идентификатора и области видимости \\
    \hline Прямое ребро & Ограничение графа областей & Две области видимости & Обозначение прямой связи
    между областями, моделирование лексических областей видимости \\
    \hline Ассоциация & Ограничение графа областей & Идентификатор или переменная, Область видимости; & <<Именование>> определенной
    области видимости, либо указание того что данный идентификатор имеет привязанную область видимости \\
    \hline Разрешение & Ограничение графа областей & Идентификатор, идентификатор или переменная; & Указание того что
    данный идентификатор должен быть разрешен либо в указанный идентификатор, либо в подстановку переменной \\
    \hline Уникальность & Ограничение графа областей & Коллекция имен & Указание что коллекция имен не содержит дубликатов
    в рамках данной области видимости \\
    \hline Подмножество & Ограничение графа областей & Две коллекции имен & Указание того, что одна коллекция
    имен входит в другую коллекцию имен \\
    \hline Аннотация типа & Типовое ограничение & Идентификатор, переменная & Указание типа определенного
    идентификатора через переменную \\
    %\hline & & & \\
    %\hline & & & \\
    %\hline & & & \\
    \hline
    \caption{Задействованные ограничения}
    \label{all-constraints}
\end{longtable}

% онтология:
% Типизация: 2.1
% структурные ограничения

\subsubsection{Вовлечение операционного окружения}

%понижение системной инфы в данные, интеграция в граф

\subsubsection{Исследование средств реализации}



\clearpage