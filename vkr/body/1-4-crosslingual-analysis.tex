\section{Анализ существующих подходов к статическому анализу, проектирование архитектуры и
исследование средств реализации}

\subsubsection{Виды структур представления информации в статическом анализе}

Из подраздела \ref{ssec:2:results} становится ясно, что в отношении мультиязыкового анализа
основополагающим механизмом является наличие общей структуры представления информации, позволяющей отражать различные
сущности различных языков в единой форме. Выбор такой структуры может влиять на следующие
характеристики метода анализа:
\begin{itemize}
    \item разнообразие поддерживаемых языков,
    \item сложность разработки и поддержки анализаторов,
    \item корректность и полнота анализа,
    \item возможные сценарии использования.
\end{itemize}
В целом, выбор структуры влияет практически на все характеристики метода, поэтому стоит
исследовать существующие структуры представления информации о программном коде.

\hyperlink{AST}{AST} представляет собой репрезентацию программного кода в древовидном формате. В качестве узлов дерева выступают различные синтаксические конструкции, а в качестве ребер связи между ними. AST является
простой и универсальной структурой данных, позволяющей реализовывать множество анализов. Также,
носителем AST может быть любой структурный формат (например S-выражения), что упрощает его
построение, сериализацию и анализ. Однако, в контексте мультиязыкового анализа AST является
неудобным решением, в первую очередь потому что оно часто вовлекает языкоспецифичные конструкции.
К примеру, в некоторых языках отсутствует понятие <<оператор>> (англ statement), что различает
AST таких языков от императивных языков на фундаментальном уровне.

eCST \cite{eCST} является попыткой расширения концепции AST (а точнее \hyperlink{CST}{CST}) на большее
количество языков. Авторы достигают этого путем введения универсальных узлов, позволяющих
отражать общие семантические концепции (итерацию, выбор или переход). К сожалению, такой формат
представления информации всё еще неудобен так как языкоспецифичные узлы не могут быть конвертированы
в такие универсальные узлы и остаются в дереве в первозданном виде.

\hyperlink{CFG}{CFG} это граф, узлы которого представляют собой в общем случае операторы, а ребра
поток управления. Такой граф полезен в первую очередь для компиляторных трансформаций и оптимизаций,
так как позволяет моделировать исполнение программы и выстраивать на основе этого определенные инварианты.
Граф является основой для фреймворков монотонного анализа \cite{static-program-analysis} и активно
используется в различных инструментах. Несмотря на достоинства, как и в случае с AST такой граф
имеет зависимость от представляемого языка. Также, анализ потока управления сложен в контексте
мультиязыкового статического анализа и проще осуществим в рамках динамического анализа.

\hyperlink{CDG}{CDG} является формой представления информации о вызовах процедур друг другом в контексте
определенного фрагмента кода. Соотвественно, узлы такого графа обычно составляют идентификаторы
процедур, а ребра зависимость <<вызывает>>. Стоит сказать, что зависимость <<вызывает>> обычно является
направленной, поэтому граф имеет направление ребер. Такой граф является хорошим кандидатом на универсальное
представление в рамках мультиязыкового анализа, что уже было исследовано в \cite{MLSA}. Как было
сказано в подразделе \ref{ssec:mlsa}, основным недостатком графа зависимостей вызовов является
его ориентированность на процедуры -- исполняемые фрагменты кода. Это делает невозможным его применение
в рамках других языков, в первую очередь форматов данных. Действительно, в современных приложениях
семантически важная информация часто содержится в различных конфигурационных файлах, например XML или
INI.

Система типов обычно не является ни структурой данных ни моделью представления семантической информации.
Её основное назначение заключается именно в проверке программ на определенные классы ошибок,
что достигается путем задания четкого математического базиса с дальнейшей проверкой предъявляемых
суждений. Однако, современные исследования в области системы типов показывают, что
есть возможность кодирования и эффективной проверки ряда свойств программного кода, часть
которых могла быть проверена только интенсивным статическим анализом. Примером является
механизм borrow-checking в языке Rust \cite{rust}, который базируется на системе типов известной
как система \textit{владения}. Такой механизм позволяет проверять и устранять класс ошибок связанных
с системными ресурсами: использование после освобождение, предотвращенние гонок данных и другие.
В контексте мультиязыкового анализа система типов точно имеет первостепенное значение, так
как создание корректных анализаторов возможно в том числе за счет использования корректной
системы типов. Однако, одной системы типов для совершения анализа недостаточно, так как
обычно ограничения на типы сущностей не берут в расчет механизмы областей видимости языков
и семантику зависимостей сущностей между собой.



В таблице \ref{analysis-structures} представлены существующие популярные структуры, используемые
для представления информации в анализе ПО. Также, в таблицу включены модели, не являющиеся структурами
данных, но тоже активно применяемые в анализе.

\begin{table}[h]
    \caption{Структуры и модели представления информации в анализе ПО}
    \resizebox{1 \textwidth}{!}{\begin{tabular}{|p{2.8cm}|p{2.5cm}|p{3cm}|p{3cm}|p{3cm}|p{3.3cm}|}
    \hline Структура\slash Модель &
        Основное назначение & 
        Устройство & 
        Достоинства в контексте мультиязыкового анализа &
        Недостатки в контексте мультиязыкового анализа  \\
    \hline AST &
        Представление программного кода в древовидном формате &
        Дерево, узлы которого представляют синтаксические конструкции, а ребра их связи &
        Простая, универсальная структура данных &
        Очень часто языкоспецифичная, сложно расширяемая для множества языков одновременно \\
    \hline
    \end{tabular}}\label{analysis-structures}
\end{table}

% eCST: https://arxiv.org/pdf/1310.0802.pdf

% SPA 

% file:///home/uber/dev/mag/crosslingual-analysis/reports/sem2/%D0%9E%D1%80%D0%BB%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9%D0%9C%D0%AE_%D0%9E%D1%82%D1%87%D0%B5%D1%82_%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0.pdf
% Различные подходы к семантической инфе 1.3 + проблема модулей
% file:///home/uber/dev/mag/crosslingual-analysis/reports/sem3/%D0%9E%D1%80%D0%BB%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9%20%D0%9C.%D0%AE.%20%D0%9E%D1%82%D1%87%D0%B5%D1%82%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0.pdf

\subsubsection{Парсинг мультиязыковых фрагментов кода}

% Генераторы парсеров 3.1
% распознавалка

\subsubsection{Универсальная <<таблица символов>>}

% онтология:
% Типизация: 2.1
% структурные ограничения

\subsubsection{Вовлечение операционного окружения}

%понижение системной инфы в данные, интеграция в граф

\subsubsection{Исследование средств реализации}



\clearpage