\section{Анализ существующих подходов к статическому анализу, проектирование архитектуры и
исследование средств реализации}

\subsubsection{Виды структур представления информации в статическом анализе}

Из подраздела \ref{ssec:2:results} становится ясно, что в отношении мультиязыкового анализа
основополагающим механизмом является наличие общей структуры представления информации, позволяющей отражать различные
сущности различных языков в единой форме. Выбор такой структуры может влиять на следующие
характеристики метода анализа:
\begin{itemize}
    \item разнообразие поддерживаемых языков,
    \item сложность разработки и поддержки анализаторов,
    \item корректность и полнота анализа,
    \item возможные сценарии использования.
\end{itemize}
В целом, выбор структуры влияет практически на все характеристики метода, поэтому стоит
исследовать существующие структуры представления информации о программном коде.

\hyperlink{AST}{AST} представляет собой репрезентацию программного кода в древовидном формате. В качестве узлов дерева выступают различные синтаксические конструкции, а в качестве ребер связи между ними. AST является
простой и универсальной структурой данных, позволяющей реализовывать множество анализов. Также,
носителем AST может быть любой структурный формат (например S-выражения), что упрощает его
построение, сериализацию и анализ. Однако, в контексте мультиязыкового анализа AST является
неудобным решением, в первую очередь потому что оно часто вовлекает языкоспецифичные конструкции.
К примеру, в некоторых языках отсутствует понятие <<оператор>> (англ statement), что различает
AST таких языков от императивных языков на фундаментальном уровне.

eCST \cite{eCST} является попыткой расширения концепции AST (а точнее \hyperlink{CST}{CST}) на большее
количество языков. Авторы достигают этого путем введения универсальных узлов, позволяющих
отражать общие семантические концепции (итерацию, выбор или переход). К сожалению, такой формат
представления информации всё еще неудобен так как языкоспецифичные узлы не могут быть конвертированы
в такие универсальные узлы и остаются в дереве в первозданном виде.

\hyperlink{CFG}{CFG} это граф, узлы которого представляют собой в общем случае операторы, а ребра
поток управления. Такой граф полезен в первую очередь для компиляторных трансформаций и оптимизаций,
так как позволяет моделировать исполнение программы и выстраивать на основе этого определенные инварианты.
Граф является основой для фреймворков монотонного анализа \cite{static-program-analysis} и активно
используется в различных инструментах. Несмотря на достоинства, как и в случае с AST такой граф
имеет зависимость от представляемого языка. Также, анализ потока управления сложен в контексте
мультиязыкового статического анализа и проще осуществим в рамках динамического анализа.

\hyperlink{CDG}{CDG} является формой представления информации о вызовах процедур друг другом в контексте
определенного фрагмента кода. Соотвественно, узлы такого графа обычно составляют идентификаторы
процедур, а ребра зависимость <<вызывает>>. Стоит сказать, что зависимость <<вызывает>> обычно является
направленной, поэтому граф имеет направление ребер. Такой граф является хорошим кандидатом на универсальное
представление в рамках мультиязыкового анализа, что уже было исследовано в \cite{MLSA}. Как было
сказано в подразделе \ref{ssec:mlsa}, основным недостатком графа зависимостей вызовов является
его ориентированность на процедуры -- исполняемые фрагменты кода. Это делает невозможным его применение
в рамках других языков, в первую очередь форматов данных. Действительно, в современных приложениях
семантически важная информация часто содержится в различных конфигурационных файлах, например XML или
INI.

Система типов обычно не является ни структурой данных ни моделью представления семантической информации.
Её основное назначение заключается именно в проверке программ на определенные классы ошибок,
что достигается путем задания определенного набора суждений о сущностях в программе с
их дальнейшей автоматической проверкой.
Однако, современные исследования в области системы типов показывают, что
есть возможность кодирования и эффективной проверки ряда свойств программного кода, часть
которых раньше могла быть проверена только интенсивным статическим анализом. Примером является
механизм borrow-checking в языке Rust \cite{rust}, который базируется на системе типов известной
как система \textit{владения}. Такой механизм позволяет проверять и устранять класс ошибок связанных
с системными ресурсами: использование после освобождения, предотвращенние гонок данных и другие.
В контексте мультиязыкового анализа система типов точно имеет первостепенное значение, так
как создание корректных анализаторов возможно в том числе за счет использования корректной
системы типов. Однако, одной системы типов для совершения анализа недостаточно, так как
обычно ограничения на типы сущностей не берут в расчет механизмы областей видимости языков
и семантику зависимостей сущностей между собой.

Таблица символов является повсеместной структурой данных (особенно в императивных языках) и
используется в первую очередь для представления различной информации об идентификаторах. Так,
таблица символов обычно содержит данные о местонахождении определения (или объявления) сущности,
её тип, контекст в котором она определена и множество других атрибутов, специфичных для конкретного
языка. Структурно таблица символов представляет собой набор пар (идентификатор, атрибуты).
Первым и значимым расширением концепции таблицы символов является введение понятия \textit{области видимости}.
В языках с лексической областью видимости таблица символов является не таблицей, а стеком таблиц --
это необходимо для отражения отношения вложенности между областями видимости. Таблица символов
является очень хорошим решением в контексте мультиязыкового анализа, но имеет один серьезный недостаток.
Он заключается в отсутствии возможности однозначного кодирования нелексических
областей видимости, например в случае присутствия в языке механизма классов или модулей.

Граф свойств может быть определен в терминах теории графов как направленный 
мультиграф с метками вершин и ребер с собственными ребрами, 
где ребра имеют собственную идентичность \cite{property-graph}.
Такие графы активно используются в графовых базах данных и хорошо подходят для отражения
разноструктурированной онтологической информации о сущностях в области знаний.
Например, формат RDF \cite{RDF} является основным способом представления информации
в семантических сетях Интернета. Основанные на нем языки отражения онтологических
понятий позволяют создавать машинно-читаемые семантические структуры.
Основным недостатком графов свойств в контексте мультиязыкового анализа ПО является отсутствие
сколько нибудь универсальной единой онтологической модели. Соотвественно, существующие
модели (что рассмотрены в подразделе \ref{ssec:pangea}) являются специфичными решениями.
Также, создание и поддержка таких моделей является довольно трудоемким процессом, так как требует
достаточной компетенции специалиста.

Таким образом, на данный момент не существует идеальной структуры представления информации
для осуществлений мультиязыкового анализа. Однако, существующие структуры и модели дают
представление о том, какой она могла бы быть -- идеальная модель являлась бы совмещением
концепций системы типов и таблицы символов, с дополнительной возможностью связывания
понятий по онтологическим признакам в определенные графы свойств. Таким образом, так или иначе
такая модель должна реализовывать формат семантической сети в общем случае.

% eCST: https://arxiv.org/pdf/1310.0802.pdf

% SPA 

% file:///home/uber/dev/mag/crosslingual-analysis/reports/sem2/%D0%9E%D1%80%D0%BB%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9%D0%9C%D0%AE_%D0%9E%D1%82%D1%87%D0%B5%D1%82_%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0.pdf
% Различные подходы к семантической инфе 1.3 + проблема модулей
% file:///home/uber/dev/mag/crosslingual-analysis/reports/sem3/%D0%9E%D1%80%D0%BB%D0%BE%D0%B2%D1%81%D0%BA%D0%B8%D0%B9%20%D0%9C.%D0%AE.%20%D0%9E%D1%82%D1%87%D0%B5%D1%82%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0.pdf

\subsubsection{Парсинг мультиязыковых фрагментов кода}

Как было сказано в подразделе \ref{ssec:parsing-problem}, парсинг текста является одной из первых
задач, которые необходимо решить при мультязыковом анализе. При наличии единой модели представления информации,
однако, такая задача существенно упрощается.

Дело в том, что используя единую модель состоящую из графа можно достичь разделения этапов
извлечения информации о графе и анализа самого графа. Похожий подход используется, например, при
реализации проверки типов методом Хиндли-Милнера \cite{algorithm-W}. Суть алгоритма заключается
в использовании т.н. \textit{ограничений} которые извлекаются из кода. Такие ограничения являются
утверждениями о сущностях и в дальнейшем решаются вместе для создания специальной подстановки, которая
позволит удовлетворить все ограничения. Такой процесс решения называется \textit{унификацией}.

По тому же принципу можно построить модель для мультиязыкового анализа, если в качестве ограничений
воспринимать отношения узлов в графе, а в качесте процесса унификации процесс построения самого графа. Такой
механизм распределенного анализа позволяет достичь двух целей:
\begin{itemize}
    \item 
\end{itemize}

% Генераторы парсеров 3.1
% распознавалка

\subsubsection{Универсальная <<таблица символов>>}

% онтология:
% Типизация: 2.1
% структурные ограничения

\subsubsection{Вовлечение операционного окружения}

%понижение системной инфы в данные, интеграция в граф

\subsubsection{Исследование средств реализации}



\clearpage