
# Insights/ideas

## Универсальный анализатор (прототип реализован как prototype2)

```
    type LSPMessage = <message from lsp basically json>
    type Fragment = Text
    type Tree = <tree of text>
    type Parser = Fragment -> EBNF -> Tree # basically interpreter
    type Judgement = <AST of lambda 2>
    type Module = Graph [Judgement])
    type Relation = (Judgement, Judgement)

    translate :: Parser -> Productions -> Fragment -> Module
    analyze :: [Module] -> [Relation]

    parseLSPMessage :: LSPMessage -> Fragment
    dumpCache :: Module -> IO Filepath # and also readCache
```

1. Универсальный анализатор типовых сигнатур - на вход получает все типовые сигнатуры сущностей в форме фрагментов и выявляет их связи между собой.
    - Связи используются для обнаружения зависимостей 
    - и поддержания корректности использования идентификаторов в различных контекстах
2. Такой анализатор использует набор фрагментов и онтологию предметной области, последняя получается из контекста проекта (файла конфигурации)
3. Набор фрагментов получается из результатов работы различных моноязыковых анализаторов, переводящих изначальную типовую информацию об идентификаторах
какого-либо языка в общую форму
4. Моноязыковой анализатор представляет собой тайпчекер хостового языка с прикрученным сбоку конвентором типовых сигнатур из языка хоста в универсальное представление 
(систему типов универсального тайпчекера)
5. Система типов универсального тайпчекера предположительно что-то вроде lambda 2 и стоит еще подумать над прикручиванием системы эффектов

## Моноязыковые анализаторы
1. Я думаю стоит использовать [LSP](https://microsoft.github.io/language-server-protocol/) и собирать типовые сигнатуры через него
    * LSP Дает языко-независимую информацию. Можно считать, что из него можно вытянуть максимум что-то вроде `fn some_func(a: float, c: bool) -> Arc<unit>`
    * Следовательно, нужен микро-парсер для каждого языка, переводящий такие сигнатуры в общую форму
    * Также, неплохо было бы делать [инференс](#inference) эффектов из функций для собирания максимально достоверной сигнатуры
2. Типовые сигнатуры собираются в первую очередь для исполняемых сущностей (процедуры, функции, команды, методы etc).
Анализировать определения типов данных возможно не нужно, по крайней мере интенсивно
3. Типовые сигнатуры собираются для *идентификаторов*, литералы и выражения мимо
4. Деление на фрагменты случайное, но хорошо если оно напоминает действительную иерархию сущностей в проекте
5. Сохранение scoping rules может быть произведено через вложенность фрагментов. First-class фрагменты вещь путанная и через чур сложная для поставленных задач

# TODO

## Несрочно неважно

- [x] Подумать, нужен ли анализ неисполняемых сущностей, в первую очередь определений типов данных для межфрагментного анализа
    * Не нужен

## Несрочно важно

- [ ] Изменить описание про MLSA в итоговой ВКР
- [ ] Почитать https://arxiv.org/abs/1808.01210
- [x] Расписать про дихотомию исполняется/неисполняется, использовать статью <?>
- [ ] Расписать про ценности анализа
    - [ ] Анализ на основе формальной модели, завязанной на фрагментах (модулях) и их линковке
    - [ ] Механизм дальнейшей эксплуатации информации о связях
- [x] Почитать про [LSP](https://microsoft.github.io/language-server-protocol/)
- [ ] Возможно, инференс эффектов и парсер можно сделать тупо через конфигурацию?
    * ```{ "io-effect": ["print", "console.log", ...], "function-signature": "<EBNF grammar rules>", }```
- [x] Проработать fallback анализ (для кейсов с например встроенными языками)
    * Эта задача в любом случае должна быть решена, вне зависимости от анализа (LSP дает недостаточную инфу)
    * Поэтому, думается использовать программируемый парсер `parser :: EBNF -> Program -> ParseTree` 
        и потом анализировать `analyzer :: (ParseTree, NodeMapper) -> (AST, Effects)` где 
        - NodeMapper - правила для маппинга ParseTree в универсальное AST (вероятно, это должно быть что-то вроде Type)
        - AST - сигнатура в формате lambda 2 (или ином)
        - Effects - кортеж из возможных эффектов этой функции
- [ ] Хороший первый прототип - анализатор который полностью корректно пробрасывает все запросы от ide в моно lsp, но не делает анализа (identity анализатор) 

## Срочно неважно

- [x] Сделать разноплановые тесты на прототип 2
- [x] Обзор текущих конференций (напр КМУ)
- [ ] Ису достижения
- [ ] Манир по результатам прошлого года, ближайшая конференция - майоровские чтения

## Срочно важно

- [x] Отчет по 2 семестру
- [x] Отчет: Do another prototype, consult language and implications of that (maybe go for abstract analyzer in something simple like Go?)
- [x] Отчет: Do prototype for at least three scenarious, all different kind
- [x] Отчет: Test, maybe benchmark stuff
- [x] Отчет: Write discussion basically (maybe not full)
    - [x] Отписать про внутримодульный и межмодульный анализ
- [x] Прототип 2, гетерогенный лист
- [x] Прототип 2, семантическая сеть и анализатор
- [x] Прототип 2, юзкейс 1
    - [x] анализ
- [x] Прототип 2, юзкейс 2
    - [x] анализ
- [x] Прототип 2, юзкейс 3
    - [x] анализ
- [x] Рассмотреть идею взаимодействия языков в юзкейсах как модулей
- [x] Ввести онтологию для такого универсального межмодульного взаимодействия
- [x] Презентация

