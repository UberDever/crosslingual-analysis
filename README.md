
# Insights/ideas

## Универсальный анализатор (прототип реализован как prototype2)

```
    type LSPMessage = <message from lsp basically json>
    type Fragment = Text
    type Tree = <tree of text>
    type Parser = Fragment -> EBNF -> Tree # basically interpreter
    type Judgement = <AST of lambda 2>
    type Module = Graph [Judgement]
    type Relation = (Judgement, Judgement)

    translate :: Parser -> Productions -> Fragment -> Module
    analyze :: [Module] -> [Relation]

    parseLSPMessage :: LSPMessage -> Fragment
    dumpCache :: Module -> IO Filepath # and also readCache
```

Терм - фрагмент кода, уникально идентифицируемый в рамках всей системы, имеет тип
Тип - тип из системы типизации lambda2
Архетип - common known структура термов (1) и её тип (2), которые отражают дополнительную информацию о предметной области

Онтология включает:
- Правила связи между языками (видимость, наличие связи) и семантику (название) этой связи
- Наверняка правила связи внутри языка (видимость)
- Архетипы (возможно однопараметрические конструкторы)

1. Универсальный анализатор типовых сигнатур - на вход получает все типовые сигнатуры сущностей в форме вложенных фрагментов и выявляет их связи между собой.
    - Связи используются для обнаружения зависимостей 
    - и поддержания корректности использования сущностей в различных контекстах
1. Такой анализатор использует набор фрагментов и онтологию предметной области, последняя получается из контекста проекта (файла конфигурации)
1. Набор фрагментов получается из результатов работы различных моноязыковых анализаторов, переводящих изначальную типовую информацию 
какого-либо языка в общую форму
1. Система типов универсального тайпчекера предположительно что-то вроде lambda 2
1. Фрагменты подчиняются правилу линковки модулей, предположительно из пейпера Карделли

## Моноязыковые анализаторы
1. Я думаю стоит использовать [LSP](https://microsoft.github.io/language-server-protocol/) и собирать типовые сигнатуры через него
    * LSP Дает языко-независимую информацию. Можно считать, что из него можно вытянуть максимум что-то вроде `fn some_func(a: float, c: bool) -> Arc<unit>`
    * Следовательно, нужен микро-транслятор для каждого языка, переводящий такие сигнатуры в структурированные фрагменты
    * Т.к. трансляция чисто индуктивная, можно использовать Postorder и получится ad hoc syntax directed translation
1. Типовые сигнатуры собираются только для того что можно в каком-то отношении считать `public`
1. Каждый терм имеет окружение и сигнатуру состоящую из окружений и сигнатур своих поддтеров + свою собственную
1. Деление на фрагменты случайное, но хорошо если оно напоминает действительную иерархию сущностей в проекте
1. Сохранение scoping rules может быть произведено через вложенность фрагментов. First-class фрагменты вещь путанная и через чур сложная для поставленных задач
1. Термы имеют области видимости (наверняка характеризуемые числом) которые позволяют контроллировать name-aliasing

# TODO

## Несрочно неважно

- [x] Подумать, нужен ли анализ неисполняемых сущностей, в первую очередь определений типов данных для межфрагментного анализа
    * Не нужен

## Несрочно важно

- [ ] Изменить описание про MLSA в итоговой ВКР
- [ ] Почитать https://arxiv.org/abs/1808.01210
- [x] Расписать про дихотомию исполняется/неисполняется, использовать статью <?>
- [ ] Расписать про ценности анализа
    - [ ] Анализ на основе формальной модели, завязанной на фрагментах (модулях) и их линковке
    - [ ] Механизм дальнейшей эксплуатации информации о связях
- [x] Почитать про [LSP](https://microsoft.github.io/language-server-protocol/)
- [x] Возможно, инференс эффектов и парсер можно сделать тупо через конфигурацию? No
- [x] Проработать fallback анализ (для кейсов с например встроенными языками)
- [ ] Хороший первый прототип - анализатор который полностью корректно пробрасывает все запросы от ide в моно lsp, но не делает анализа (identity анализатор) 
- [x] Почитать [BSP](https://build-server-protocol.github.io/)
    - Фигня сырая...
- [ ] Порисерчить парсинг для МЯ программ
    - [ ] Дочитать диссер
- [ ] Использовать ad hoc directed translation для построения фрагментов
- [ ] Описать фрагменты и их семантику более формально

## Срочно неважно

- [x] Сделать разноплановые тесты на прототип 2
- [x] Обзор текущих конференций (напр КМУ)
- [ ] Ису достижения
- [ ] Манир по результатам прошлого года, ближайшая конференция - майоровские чтения

## Срочно важно

- [x] Отчет по 2 семестру
- [x] Отчет: Do another prototype, consult language and implications of that (maybe go for abstract analyzer in something simple like Go?)
- [x] Отчет: Do prototype for at least three scenarious, all different kind
- [x] Отчет: Test, maybe benchmark stuff
- [x] Отчет: Write discussion basically (maybe not full)
    - [x] Отписать про внутримодульный и межмодульный анализ
- [x] Прототип 2, гетерогенный лист
- [x] Прототип 2, семантическая сеть и анализатор
- [x] Прототип 2, юзкейс 1
    - [x] анализ
- [x] Прототип 2, юзкейс 2
    - [x] анализ
- [x] Прототип 2, юзкейс 3
    - [x] анализ
- [x] Рассмотреть идею взаимодействия языков в юзкейсах как модулей
- [x] Ввести онтологию для такого универсального межмодульного взаимодействия
- [x] Презентация

